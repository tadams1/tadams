<body onload="webGLStart();">
  <canvas id="mycanvas" style="border: none;" width="640" height="500"></canvas>
  <br/>
</body>

<script type="text/javascript" src="./glMatrix-0.9.5.min.js"></script>


<script id="shader-std-fs" type="x-shader/x-fragment">
  precision mediump float;
  varying vec2 vTextureCoord;
  varying vec3 vLightWeighting;

  void main(void) {
     gl_FragColor = vec4(vec3(1.1,1.0,0.0) * vLightWeighting,1);

    //if(vTextureCoord.s == 1.0) {
    //  gl_FragColor = vec4(0.1, 1.0, 0.0, 1.0);
    //} else {
    //  gl_FragColor = vec4(0.1, 1.0, 1.0, 1.0);
    //}
    //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  }

</script>

<script id="shader-std-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;
  
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  uniform mat3 uNMatrix;

  uniform vec3 uLightingDirection;
  uniform vec3 uDirectionalColor;
  varying vec3 vLightWeighting;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

    vec3 transformedNormal = uNMatrix * aVertexNormal;
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
    vLightWeighting = vec3(0.2,0.2,0.2) + vec3(0.0,0.8,0.8) * directionalLightWeighting;
 
    //gl_Position = vec4(aVertexPosition, 1.0);
    
    //vTextureCoord = aTextureCoord;
  }
</script>

<script id="shader-brot-fs" type="x-shader/x-fragment">
	
  #define NUM_STEPS   20
  #define ZOOM_FACTOR 2.0
  #define X_OFFSET    0.5
 
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  
  precision mediump int;
 
  void main() {
    vec2 z;
    float x,y;
    int steps;
    float normalizedX = (gl_FragCoord.x - 320.0) / 640.0 * ZOOM_FACTOR *
                        (640.0 / 480.0) - X_OFFSET;
    float normalizedY = (gl_FragCoord.y - 240.0) / 480.0 * ZOOM_FACTOR;
 
    z.x = normalizedX;
    z.y = normalizedY;
 
    for (int i=0;i<NUM_STEPS;i++) {
 
      steps = i;
 
      x = (z.x * z.x - z.y * z.y) + normalizedX;
      y = (z.y * z.x + z.x * z.y) + normalizedY;
 
      if((x * x + y * y) > 4.0) {
        break;
      }
 
        z.x = x;
        z.y = y;
 
    }
 
    if (steps == NUM_STEPS-1) {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
</script>

<script id="shader-brot-vs" type="x-shader/x-vertex">

	attribute vec2 a_position;

  	void main() {
		gl_Position = vec4(a_position, 0, 1);
  	}
</script>

<script>
	var gl;
  var mvMatrix = mat4.create();
  var pMatrix = mat4.create();
	var canvas;


	function webGLStart() {
    canvas = document.getElementById("mycanvas");
    initGL(canvas);
    initShadersWF();
    //initBuffers();
    //initTexture();
    initWFBuffers();
    //render();
	}

	var buffer;

  function initWFBuffers() {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-30.0, 0.0, -60.0]);
    mat4.rotate(mvMatrix, -0.65, [1, 0, 0]);

    setMatrixUniforms();
  
    var w = 100;
    var h = 100;

    var ic = getVerticesCount2();
  
    var vData = getVertices2(w,h);
    
    console.log(vData.vertices);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER,
    vData.vertices,
      gl.STATIC_DRAW
    );   
    buffer.itemSize = 3;
    buffer.numItems = ic/3;
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, buffer.itemSize, gl.FLOAT, false, 0, 0);

    
    var c = getIndicies2(w,h);
    indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, c, gl.STATIC_DRAW);
    indexBuffer.itemSize = 1;
    indexBuffer.numItems = getIncidiesCount2(w,h);
    console.log(c);
    

   
    console.log(vData.normals);
    normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer, gl.STATIC_DRAW);
    gl.bufferData(gl.ARRAY_BUFFER,
      vData.normals,
      gl.STATIC_DRAW
    );
    normalBuffer.itemSize = 3;
    normalBuffer.numItems = ic/3;
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
  
 
    var adjustedLD = vec3.create();
    var ld = [-0.25,1,-1];
    console.log(ld);
    vec3.normalize(ld, adjustedLD);
    vec3.scale(adjustedLD, -1);
    console.log(adjustedLD);
    gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);


    /*testbuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, testbuffer);
    var testIndex = 
      [0, 5, 1, 6, 2, 7, 3, 8, 4, 9, 9, 5, 4, 9, 5, 10, 6, 11, 7]
    
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(testIndex), gl.STATIC_DRAW);
    testbuffer.itemSize = 1;
    testbuffer.numItems = 19;*/


    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.TRIANGLE_STRIP, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, testbuffer);
    //gl.drawElements(gl.LINE_STRIP, testbuffer.numItems, gl.UNSIGNED_SHORT, 0);
    
    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer.numItems);
    //gl.drawArrays(gl.LINE_STRIP,0,buffer.numItems);
  
  }

	function render() {
		//window.requestAnimationFrame(render, canvas);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    	//gl.enable(gl.DEPTH_TEST);
		gl.clear(gl.COLOR_BUFFER_BIT);

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-1.5, 25.0, -17.0]);

	 	buffer = gl.createBuffer();
  		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  		gl.bufferData(
    	gl.ARRAY_BUFFER, 
    	new Float32Array([
      		-1.0, -1.0, 
       		1.0, -1.0, 
      		-1.0,  1.0, 
      		-1.0,  1.0, 
       		1.0, -1.0, 
       		1.0,  1.0]), 
    	gl.STATIC_DRAW
  		);
    buffer.itemSize = 2;
    buffer.numItems = 24;
    shaderProgram.positionLocation = gl.getAttribLocation(shaderProgram, "a_position");
    gl.enableVertexAttribArray(shaderProgram.positionLocation);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);


    gl.vertexAttribPointer(shaderProgram.positionLocation, 2, gl.FLOAT, true, 0.0, 0.0);

  	gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

 	function initGL(canvas) {
    	try {
      		gl = canvas.getContext("experimental-webgl");
      		gl.viewportWidth = canvas.width;
      		gl.viewportHeight = canvas.height;
      		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
 
    	} catch(e) {
    	}
    
    	if (!gl) {
      		alert("Could not initialise WebGL, sorry :-( ");
    	}
  	}

	var shaderProgram;
  function initShadersWF() {
    var fragmentShader = getShader(gl, "shader-std-fs");
    var vertexShader = getShader(gl, "shader-std-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  
    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");

    shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");

  }

	function initShadersBrot() {
		var fragmentShader = getShader(gl, "shader-brot-fs");
		var vertexShader = getShader(gl, "shader-brot-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

	}



  function getVerticesCount(w, h) {
    return w*h*3;
  }

  function getIndicesCount(w,h) {
    return (w*h) + (w-1) * (h-2);
  }

  function getVertices(w,h) {

    var c = getVerticesCount(w,h);
    var vrt = new Float32Array(c);
    var i = 0;
    for(var row=0; row<h; row++) {
      for(var col = 0; col<w; col++) {
        vrt[i++] = col;
        vrt[i++] = row;
        vrt[i++] = 0.0;
      }
    }
    return vrt;

  }

  function getVerticesCount2(w,h) {
    return total_vertices = (w+1) * (h+1)*3;
  }
  function getVertices2(w, h, b, n) {
    w++;
    h++;

    var total_vertices = (w) * (h)*3;
    vert = new Float32Array(total_vertices);
    normals = new Float32Array(total_vertices);

    for(var y = 0; y < h; y++) {
      var base = y * w;
      for(var x = 0; x < w; x++) {
        var index = (base + x)*3;
        vert[index]=x;
        vert[index+1]=y;
        var c = ((x-20)*(x-20))+((y-20)*(y-20));
        if(c<100) {
          vert[index+2]=-1*(Math.sqrt(100)-Math.sqrt(c));
          normals[index]=(x-20)/Math.sqrt(100);
          normals[index+1]=(x-20)/Math.sqrt(100);
          normals[index+2]=(Math.sqrt(100)-Math.sqrt(c))/Math.sqrt(100);
        } else {
          vert[index+2] = 0;
          normals[index] = 0;
          normals[index+1] = 0;
          normals[index+2]= 1;
        }
        //[index+2]=-1*mandelIter2(x,y);
      }
    }

    return {
      vertices: vert,
      normals: normals
    }
  }

function mandelIter2(cx, cy, normal) {
 /* if(cx>10 && cx < 25 && cy > 10 && cy < 25) {
    return -10;
  } else {
    return 0;
  }*/

  var c = ((cx-20)*(cx-20)) + ((cy-20)*(cy-20));
  if(c<100){

    return (Math.sqrt(100)-Math.sqrt(c));
  }
  else{
    return 0;
  }
}

function mandelIter(cx, cy, maxIter) {
  cx = cx/40;
  cy = cy/40;
  var x = 0.0;
  var y = 0.0;
  var xx = 0;
  var yy = 0;
  var xy = 0;
 
  var i = maxIter;
  while (i-- && xx + yy <= 4) {
    xy = x * y;
    xx = x * x;
    yy = y * y;
    x = xx - yy + cx;
    y = xy + xy + cy;
  }

  return maxIter - i;
}
 

  function getZ(x,y,sz) {
    
   var steps;
  
    xin = (x)/40;
    yin = (y)/40;
    var NUM_STEPS=30;
    x=xin;
    y=yin;
    for (var i=0;i<NUM_STEPS;i++) {

      xx = (x * x - y * y)+xin;
      yy = (y * x + x * y)+yin;
 
      if((xx * xx + yy * yy) > 4.0) {
        return i;
      }
 
        x = xx;
        y = yy;
    }

    return 0;
  }

  function getIncidiesCount2(w,h) {
    var numIndPerRow = w * 2 + 2;
    var numIndDegensReq = (h - 1) * 2;
    return numIndPerRow * h + numIndDegensReq;
  }

  function getIndicies2(w, h) {
    var i = 0;
 
    
    indices = new Uint16Array(getIncidiesCount2(w,h));
    for(var y = 0; y < h; y++) { 
      var base = y * (w+1);

      //indices[i++] = base;
      var indices;
      for(var x = 0; x < w+1; x++) {
        indices[i++] = ((base + x));
        indices[i++] = ((base + w + x))+1;
      }

      // add a degenerate triangle (except in a last row)
      if(y < h) {
        indices[i++] = ((y + 1) * (w+1) + (w));
        indices[i++] = ((y + 1) * (w+1));
      }
    }

      return indices;
  }

  /*var getIndices(w, h) {

    indices = new int[ iSize ];
    int i = 0;

    for ( int row=0; row<height-1; row++ ) {
        if ( (row&1)==0 ) { // even rows
            for ( int col=0; col<width; col++ ) {
                indices[i++] = col + row * width;
                indices[i++] = col + (row+1) * width;
            }
        } else { // odd rows
            for ( int col=width-1; col>0; col-- ) {
                indices[i++] = col + (row+1) * width;
                indices[i++] = col - 1 + + row * width;
            }
        }
    }
    if ( (mHeight&1) && mHeight>2 ) {
        mpIndices[i++] = (mHeight-1) * mWidth;
    }

    return indices;
}
void render() {
    glEnableClientState( GL_VERTEX_ARRAY );
    glVertexPointer( 3, GL_FLOAT, 0, getVertices(width,height) );
    glDrawElements( GL_TRIANGLE_STRIP, getIndicesCount(width,height), GL_UNSIGNED_INT, getIndices(width,height) );
    glDisableClientState( GL_VERTEX_ARRAY );
}**/

  function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
  }

	function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
          return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3)
              str += k.textContent;
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
          return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }


    return shader;
  }


</script>
