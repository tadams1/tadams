<body onload="webGLStart();">
  <canvas id="mycanvas" style="border: none;" width="640" height="500"></canvas>
  <br/>
</body>

<script type="text/javascript" src="./glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./trianglegenerator.js"></script>


<script id="shader-std-fs" type="x-shader/x-fragment">
  precision mediump float;
  varying vec2 vTextureCoord;
  varying vec3 vLightWeighting;

  void main(void) {
     gl_FragColor = vec4(vec3(1.1,1.0,0.0) * vLightWeighting,1);

    //if(vTextureCoord.s == 1.0) {
    //  gl_FragColor = vec4(0.1, 1.0, 0.0, 1.0);
    //} else {
    //  gl_FragColor = vec4(0.1, 1.0, 1.0, 1.0);
    //}
    //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  }

</script>

<script id="shader-std-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;
  
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  uniform mat3 uNMatrix;

  uniform vec3 uLightingDirection;
  uniform vec3 uDirectionalColor;
  varying vec3 vLightWeighting;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

    vec3 transformedNormal = uNMatrix * aVertexNormal;
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
    vLightWeighting = vec3(0.2,0.2,0.2) + vec3(0.0,0.8,0.8) * directionalLightWeighting;
 
    //gl_Position = vec4(aVertexPosition, 1.0);
    
    //vTextureCoord = aTextureCoord;
  }
</script>

<script id="shader-brot-fs" type="x-shader/x-fragment">
	
  #define NUM_STEPS   20
  #define ZOOM_FACTOR 2.0
  #define X_OFFSET    0.5
 
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  
  precision mediump int;
 
  void main() {
    vec2 z;
    float x,y;
    int steps;
    float normalizedX = (gl_FragCoord.x - 320.0) / 640.0 * ZOOM_FACTOR *
                        (640.0 / 480.0) - X_OFFSET;
    float normalizedY = (gl_FragCoord.y - 240.0) / 480.0 * ZOOM_FACTOR;
 
    z.x = normalizedX;
    z.y = normalizedY;
 
    for (int i=0;i<NUM_STEPS;i++) {
 
      steps = i;
 
      x = (z.x * z.x - z.y * z.y) + normalizedX;
      y = (z.y * z.x + z.x * z.y) + normalizedY;
 
      if((x * x + y * y) > 4.0) {
        break;
      }
 
        z.x = x;
        z.y = y;
 
    }
 
    if (steps == NUM_STEPS-1) {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
</script>

<script id="shader-brot-vs" type="x-shader/x-vertex">

	attribute vec2 a_position;

  	void main() {
		gl_Position = vec4(a_position, 0, 1);
  	}
</script>

<script>
	var gl;
  var mvMatrix = mat4.create();
  var pMatrix = mat4.create();
	var canvas;


	function webGLStart() {
    canvas = document.getElementById("mycanvas");
    initGL(canvas);
    initShadersWF();
    //initBuffers();
    //initTexture();
    initWFBuffers();
    //render();
	}

	var buffer;

  function initWFBuffers() {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-30.0, 0.0, -60.0]);
    mat4.rotate(mvMatrix, -0.65, [1, 0, 0]);

    setMatrixUniforms();
  
    var tg = new SphereBumpGenerator();
    tg.init(100,100,10,20,20);

    var w = 100;
    var h = 100;

    var ic = tg.getVerticesCount();
    var vData = tg.getVectices();
    console.log(vData.vertices);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER,
    vData.vertices,
      gl.STATIC_DRAW
    );   
    buffer.itemSize = 3;
    buffer.numItems = ic/3;
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, buffer.itemSize, gl.FLOAT, false, 0, 0);

    
    var c = tg.getIndices();
    indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, c, gl.STATIC_DRAW);
    indexBuffer.itemSize = 1;
    indexBuffer.numItems = tg.getIndicesCount();
    console.log(c);
    

   
    //console.log("Normals" + vData.vertices);
    normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer, gl.STATIC_DRAW);
    gl.bufferData(gl.ARRAY_BUFFER,
      vData.normals,
      gl.STATIC_DRAW
    );
    normalBuffer.itemSize = 3;
    normalBuffer.numItems = ic/3;
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
  
 
    var adjustedLD = vec3.create();
    var ld = [-0.25,1,-1];
    console.log(ld);
    vec3.normalize(ld, adjustedLD);
    vec3.scale(adjustedLD, -1);
    console.log(adjustedLD);
    gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);


    /*testbuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, testbuffer);
    var testIndex = 
      [0, 5, 1, 6, 2, 7, 3, 8, 4, 9, 9, 5, 4, 9, 5, 10, 6, 11, 7]
    
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(testIndex), gl.STATIC_DRAW);
    testbuffer.itemSize = 1;
    testbuffer.numItems = 19;*/


    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.LINE_STRIP, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, testbuffer);
    //gl.drawElements(gl.LINE_STRIP, testbuffer.numItems, gl.UNSIGNED_SHORT, 0);
    
    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer.numItems);
    //gl.drawArrays(gl.LINE_STRIP,0,buffer.numItems);
  
  }

	function render() {
		//window.requestAnimationFrame(render, canvas);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    	//gl.enable(gl.DEPTH_TEST);
		gl.clear(gl.COLOR_BUFFER_BIT);

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-1.5, 25.0, -17.0]);

	 	buffer = gl.createBuffer();
  		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  		gl.bufferData(
    	gl.ARRAY_BUFFER, 
    	new Float32Array([
      		-1.0, -1.0, 
       		1.0, -1.0, 
      		-1.0,  1.0, 
      		-1.0,  1.0, 
       		1.0, -1.0, 
       		1.0,  1.0]), 
    	gl.STATIC_DRAW
  		);
    buffer.itemSize = 2;
    buffer.numItems = 24;
    shaderProgram.positionLocation = gl.getAttribLocation(shaderProgram, "a_position");
    gl.enableVertexAttribArray(shaderProgram.positionLocation);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);


    gl.vertexAttribPointer(shaderProgram.positionLocation, 2, gl.FLOAT, true, 0.0, 0.0);

  	gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

 	function initGL(canvas) {
    	try {
      		gl = canvas.getContext("experimental-webgl");
      		gl.viewportWidth = canvas.width;
      		gl.viewportHeight = canvas.height;
      		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
 
    	} catch(e) {
    	}
    
    	if (!gl) {
      		alert("Could not initialise WebGL, sorry :-( ");
    	}
  	}

	var shaderProgram;
  function initShadersWF() {
    var fragmentShader = getShader(gl, "shader-std-fs");
    var vertexShader = getShader(gl, "shader-std-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  
    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");

    shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");

  }

	function initShadersBrot() {
		var fragmentShader = getShader(gl, "shader-brot-fs");
		var vertexShader = getShader(gl, "shader-brot-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

	}



  
function mandelIter(cx, cy, maxIter) {
  cx = cx/40;
  cy = cy/40;
  var x = 0.0;
  var y = 0.0;
  var xx = 0;
  var yy = 0;
  var xy = 0;
 
  var i = maxIter;
  while (i-- && xx + yy <= 4) {
    xy = x * y;
    xx = x * x;
    yy = y * y;
    x = xx - yy + cx;
    y = xy + xy + cy;
  }

  return maxIter - i;
}
 

  function getZ(x,y,sz) {
    
   var steps;
  
    xin = (x)/40;
    yin = (y)/40;
    var NUM_STEPS=30;
    x=xin;
    y=yin;
    for (var i=0;i<NUM_STEPS;i++) {

      xx = (x * x - y * y)+xin;
      yy = (y * x + x * y)+yin;
 
      if((xx * xx + yy * yy) > 4.0) {
        return i;
      }
 
        x = xx;
        y = yy;
    }

    return 0;
  }

  

  function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
  }

	function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
          return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3)
              str += k.textContent;
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
          return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }


    return shader;
  }


</script>
