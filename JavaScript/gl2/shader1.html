<body onload="webGLStart();">
  <canvas id="mycanvas" style="border: none;" width="640" height="500"></canvas>
  <br/>
</body>

<script type="text/javascript" src="./glMatrix-0.9.5.min.js"></script>


<script id="shader-std-fs" type="x-shader/x-fragment">
  precision mediump float;

  void main(void) {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  }

</script>

<script id="shader-std-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec2 vTextureCoord;
  varying vec4 vColor;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    //gl_Position = vec4(aVertexPosition, 1.0);
    
    //vTextureCoord = aTextureCoord;
  }
</script>

<script id="shader-brot-fs" type="x-shader/x-fragment">
	
  #define NUM_STEPS   20
  #define ZOOM_FACTOR 2.0
  #define X_OFFSET    0.5
 
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  
  precision mediump int;
 
  void main() {
    vec2 z;
    float x,y;
    int steps;
    float normalizedX = (gl_FragCoord.x - 320.0) / 640.0 * ZOOM_FACTOR *
                        (640.0 / 480.0) - X_OFFSET;
    float normalizedY = (gl_FragCoord.y - 240.0) / 480.0 * ZOOM_FACTOR;
 
    z.x = normalizedX;
    z.y = normalizedY;
 
    for (int i=0;i<NUM_STEPS;i++) {
 
      steps = i;
 
      x = (z.x * z.x - z.y * z.y) + normalizedX;
      y = (z.y * z.x + z.x * z.y) + normalizedY;
 
      if((x * x + y * y) > 4.0) {
        break;
      }
 
        z.x = x;
        z.y = y;
 
    }
 
    if (steps == NUM_STEPS-1) {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
</script>

<script id="shader-brot-vs" type="x-shader/x-vertex">

	attribute vec2 a_position;

  	void main() {
		gl_Position = vec4(a_position, 0, 1);
  	}
</script>

<script>
	var gl;
  var mvMatrix = mat4.create();
  var pMatrix = mat4.create();
	var canvas;


	function webGLStart() {
    canvas = document.getElementById("mycanvas");
    initGL(canvas);
    initShadersWF();
    //initBuffers();
    //initTexture();
    initWFBuffers();
    //render();
	}

	var buffer;

  function initWFBuffers() {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-1.5, 0.0, -17.0]);
    setMatrixUniforms();
  
    var vertices = [
         0.0,  1.0,  0.0,
        -1.0,  1.0,  0.0,
         1.0, -1.0,  0.0,
        -1.0, -1.0,  0.0
    ];

    var b = getVertices2(3,3);
    alert(b);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER,
    b,
      gl.STATIC_DRAW
    );
    
    buffer.itemSize = 3;
    buffer.numItems = getVerticesCount(3,3)/3;
    shaderProgram.positionLocation = gl.getAttribLocation(shaderProgram, "a_position");
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, buffer.itemSize, gl.FLOAT, false, 0, 0);

    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer.numItems);
    gl.drawArrays(gl.LINE_STRIP,0,buffer.numItems);
  
  }

	function render() {
		//window.requestAnimationFrame(render, canvas);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    	//gl.enable(gl.DEPTH_TEST);
		gl.clear(gl.COLOR_BUFFER_BIT);

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);

	 	buffer = gl.createBuffer();
  		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  		gl.bufferData(
    	gl.ARRAY_BUFFER, 
    	new Float32Array([
      		-1.0, -1.0, 
       		1.0, -1.0, 
      		-1.0,  1.0, 
      		-1.0,  1.0, 
       		1.0, -1.0, 
       		1.0,  1.0]), 
    	gl.STATIC_DRAW
  		);
    buffer.itemSize = 2;
    buffer.numItems = 24;
    shaderProgram.positionLocation = gl.getAttribLocation(shaderProgram, "a_position");

    gl.enableVertexAttribArray(shaderProgram.positionLocation);
    gl.vertexAttribPointer(shaderProgram.positionLocation, 2, gl.FLOAT, true, 0.0, 0.0);

  	gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

 	function initGL(canvas) {
    	try {
      		gl = canvas.getContext("experimental-webgl");
      		gl.viewportWidth = canvas.width;
      		gl.viewportHeight = canvas.height;
      		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
 
    	} catch(e) {
    	}
    
    	if (!gl) {
      		alert("Could not initialise WebGL, sorry :-( ");
    	}
  	}

	var shaderProgram;
  function initShadersWF() {
    var fragmentShader = getShader(gl, "shader-std-fs");
    var vertexShader = getShader(gl, "shader-std-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  
 
    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
  }

	function initShadersBrot() {
		var fragmentShader = getShader(gl, "shader-brot-fs");
		var vertexShader = getShader(gl, "shader-brot-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

	}



  function getVerticesCount(w, h) {
    return w*h*3;
  }

  function getIndicesCount(w,h) {
    return (w*h) + (w-1) * (h-2);
  }

  function getVertices(w,h) {

    var c = getVerticesCount(w,h);
    var vrt = new Float32Array(c);
    var i = 0;
    for(var row=0; row<h; row++) {
      for(var col = 0; col<w; col++) {
        vrt[i++] = col;
        vrt[i++] = row;
        vrt[i++] = 0.0;
      }
    }
    return vrt;

  }


  function getVertices2(w, h) {
    w++;
    h++;

    var total_vertices = (w) * (h)*3;
    vert = new Float32Array(total_vertices);
    for(var y = 0; y < h; y++) {
      var base = y * w;
      for(var x = 0; x < w; x++) {
        var index = (base + x)*3;
        vert[index]=x;
        vert[index+1]=y;
        vert[index+2]=0;
      }
    }

    return vert;
  }

  function getIndicies2(w, h) {
    var i = 0;
  
    h--;
    for(var y = 0; y < h; y++) { 
      var base = y * w;

      //indices[i++] = (uint16)base;
      var indices;
      for(var x = 0; x < w; x++) {
        indices.push((base + x));
        indices.push((base + w + x));
      }

      // add a degenerate triangle (except in a last row)
      if(y < h - 1) {
        indices.push(((y + 1) * w + (w - 1)));
        indices.push((((y + 1) * width)));
      }
    }

      return indices;
  }

  /*var getIndices(w, h) {

    indices = new int[ iSize ];
    int i = 0;

    for ( int row=0; row<height-1; row++ ) {
        if ( (row&1)==0 ) { // even rows
            for ( int col=0; col<width; col++ ) {
                indices[i++] = col + row * width;
                indices[i++] = col + (row+1) * width;
            }
        } else { // odd rows
            for ( int col=width-1; col>0; col-- ) {
                indices[i++] = col + (row+1) * width;
                indices[i++] = col - 1 + + row * width;
            }
        }
    }
    if ( (mHeight&1) && mHeight>2 ) {
        mpIndices[i++] = (mHeight-1) * mWidth;
    }

    return indices;
}
void render() {
    glEnableClientState( GL_VERTEX_ARRAY );
    glVertexPointer( 3, GL_FLOAT, 0, getVertices(width,height) );
    glDrawElements( GL_TRIANGLE_STRIP, getIndicesCount(width,height), GL_UNSIGNED_INT, getIndices(width,height) );
    glDisableClientState( GL_VERTEX_ARRAY );
}**/

	function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
          return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3)
              str += k.textContent;
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
          return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }


    return shader;
  }

  function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
  }

</script>
